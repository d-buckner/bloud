{ config, pkgs, lib, ... }:

let
  appCfg = config.bloud.apps.authentik;
  bloudCfg = config.bloud;
  traefikCfg = config.bloud.apps.traefik;
  postgresCfg = config.bloud.apps.postgres;
  mkPodmanService = import ../../nixos/lib/podman-service.nix { inherit pkgs lib; };
  # Note: App-specific blueprints are now generated by the host-agent from metadata.yaml SSO config

  userHome = "/home/${bloudCfg.user}";
  configPath = "${userHome}/.local/share/${bloudCfg.dataDir}";
  secretsDir = configPath;

  # Shared postgres credentials
  postgresUser = postgresCfg.user or "apps";
  postgresDb = "authentik";
in
{
  options.bloud.apps.authentik = {
    enable = lib.mkEnableOption "Authentik SSO";

    port = lib.mkOption {
      type = lib.types.int;
      default = 9001;
      description = "Port to expose Authentik on";
    };

    httpsPort = lib.mkOption {
      type = lib.types.int;
      default = 9443;
      description = "HTTPS port for Authentik";
    };

    # Secret key, bootstrap password, and token are loaded from authentik.env at runtime
    # (generated by host-agent init-secrets)

    bootstrapEmail = lib.mkOption {
      type = lib.types.str;
      default = "admin@localhost";
      description = "Bootstrap admin email";
    };

    ldap = {
      enable = lib.mkOption {
        type = lib.types.bool;
        default = true;
        description = "Enable LDAP outpost for apps like Jellyfin (default: enabled)";
      };

      port = lib.mkOption {
        type = lib.types.int;
        default = 3389;
        description = "LDAP port (unencrypted)";
      };

      securePort = lib.mkOption {
        type = lib.types.int;
        default = 6636;
        description = "LDAPS port (TLS encrypted)";
      };

      # outpostToken is loaded from ldap-outpost.env at runtime (queried from Authentik)
    };
  };

  config = lib.mkIf appCfg.enable {
    bloud.pullImages = [
      "ghcr.io/goauthentik/server:2025.10.3"
      "nginx:alpine"
    ] ++ lib.optionals appCfg.ldap.enable [
      "ghcr.io/goauthentik/ldap:2025.10.3"
    ];

    # Ensure shared infrastructure is enabled
    bloud.apps.postgres.enable = true;
    bloud.apps.redis.enable = true;

    # Create Authentik directories
    system.activationScripts.bloud-authentik-dirs = lib.stringAfter [ "users" ] ''
      mkdir -p ${configPath}/{authentik-media,authentik-templates,authentik-certs,authentik-blueprints}
      mkdir -p ${configPath}/traefik/dynamic
      chown -R ${bloudCfg.user}:users ${configPath}/authentik-*
    '';

    # Copy Bloud brand blueprint (logo/favicon served from main UI /images/)
    system.activationScripts.bloud-authentik-branding = lib.stringAfter [ "bloud-authentik-dirs" ] ''
      cp ${./branding/bloud-brand.yaml} ${configPath}/authentik-blueprints/bloud-brand.yaml
      chown ${bloudCfg.user}:users ${configPath}/authentik-blueprints/bloud-brand.yaml
    '';

    # Extract Traefik routes from metadata.yaml (enables iframe embedding for SSO flows)
    # IMPORTANT: Use atomic write (write to .tmp, then mv) to prevent Traefik from
    # seeing truncated file during config reload
    system.activationScripts.bloud-authentik-traefik = lib.stringAfter [ "bloud-authentik-dirs" ] ''
      ${pkgs.yq-go}/bin/yq '.traefikConfig' ${./metadata.yaml} > ${configPath}/traefik/dynamic/authentik.yml.tmp
      mv ${configPath}/traefik/dynamic/authentik.yml.tmp ${configPath}/traefik/dynamic/authentik.yml
      chown ${bloudCfg.user}:users ${configPath}/traefik/dynamic/authentik.yml
    '';

    # Note: App-specific blueprints (actual-budget, miniflux, etc.) are now generated
    # by the host-agent from each app's metadata.yaml SSO config

    systemd.user.services = {
      # Database initialization for Authentik (creates database in shared postgres)
      authentik-db-init = {
        description = "Initialize Authentik database";
        after = [ "podman-apps-postgres.service" ];
        requires = [ "podman-apps-postgres.service" ];
        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = true;
          ExecStart = pkgs.writeShellScript "authentik-db-init" ''
            # Wait for postgres to be ready
            for i in {1..30}; do
              if ${pkgs.podman}/bin/podman exec apps-postgres psql -U ${postgresUser} -d ${postgresUser} -c "SELECT 1" &>/dev/null; then
                break
              fi
              echo "Waiting for postgres... ($i/30)"
              sleep 1
            done

            # Create database if it doesn't exist
            ${pkgs.podman}/bin/podman exec apps-postgres psql -U ${postgresUser} -c "CREATE DATABASE ${postgresDb};" 2>/dev/null || true
            ${pkgs.podman}/bin/podman exec apps-postgres psql -U ${postgresUser} -c "GRANT ALL PRIVILEGES ON DATABASE ${postgresDb} TO ${postgresUser};" || true
            echo "Authentik database ready"
          '';
        };
      };

      # Authentik Server
      podman-apps-authentik-server = mkPodmanService {
        name = "apps-authentik-server";
        image = "ghcr.io/goauthentik/server:2025.10.3";
        ports = [
          "${toString appCfg.port}:9000"
          "${toString appCfg.httpsPort}:9443"
        ];
        cmd = [ "server" ];
        # Load secrets from env file: AUTHENTIK_SECRET_KEY, AUTHENTIK_BOOTSTRAP_PASSWORD,
        # AUTHENTIK_BOOTSTRAP_TOKEN, AUTHENTIK_POSTGRESQL__PASSWORD
        envFile = "${secretsDir}/authentik.env";
        environment = {
          AUTHENTIK_REDIS__HOST = "apps-redis";
          # Use shared postgres
          AUTHENTIK_POSTGRESQL__HOST = "apps-postgres";
          AUTHENTIK_POSTGRESQL__USER = postgresUser;
          AUTHENTIK_POSTGRESQL__NAME = postgresDb;
          # AUTHENTIK_POSTGRESQL__PASSWORD loaded from envFile
          AUTHENTIK_ERROR_REPORTING__ENABLED = "false";
          # AUTHENTIK_BOOTSTRAP_PASSWORD loaded from envFile
          AUTHENTIK_BOOTSTRAP_EMAIL = appCfg.bootstrapEmail;
          # AUTHENTIK_BOOTSTRAP_TOKEN loaded from envFile
          # Enable blueprint discovery
          AUTHENTIK_BLUEPRINTS_DIR = "/blueprints";
          # External host for OAuth redirects (goes through Traefik for iframe headers)
          AUTHENTIK_HOST = "http://localhost:${toString traefikCfg.port}";
          AUTHENTIK_HOST_BROWSER = "http://localhost:${toString traefikCfg.port}";
        };
        volumes = [
          "${configPath}/authentik-media:/media:z"
          "${configPath}/authentik-templates:/templates:z"
          # Mount custom blueprints alongside default ones (don't replace /blueprints entirely)
          "${configPath}/authentik-blueprints:/blueprints/custom:z"
        ];
        network = "apps-net";
        dependsOn = [ "apps-network" "apps-postgres" "apps-redis" ];
        userns = "keep-id";
        # bloud-db-init creates the host-agent database (needed by prestart hook)
        # authentik-db-init creates the authentik database (needed by server)
        extraAfter = [ "bloud-db-init.service" "authentik-db-init.service" ];
        extraRequires = [ "bloud-db-init.service" "authentik-db-init.service" ];
        waitFor = [
          { container = "apps-postgres"; command = "pg_isready -U ${postgresUser}"; }
          { container = "apps-redis"; command = "redis-cli ping"; }
        ];
        # Wire up configurator to run after container starts (sets admin password, etc.)
        bloudAppName = "authentik";
        bloudAgentPath = bloudCfg.agentPath;
      };

      # Authentik Worker
      podman-apps-authentik-worker = mkPodmanService {
        name = "apps-authentik-worker";
        image = "ghcr.io/goauthentik/server:2025.10.3";
        cmd = [ "worker" ];
        # Load secrets from env file: AUTHENTIK_SECRET_KEY, AUTHENTIK_POSTGRESQL__PASSWORD
        envFile = "${secretsDir}/authentik.env";
        environment = {
          AUTHENTIK_REDIS__HOST = "apps-redis";
          # Use shared postgres
          AUTHENTIK_POSTGRESQL__HOST = "apps-postgres";
          AUTHENTIK_POSTGRESQL__USER = postgresUser;
          AUTHENTIK_POSTGRESQL__NAME = postgresDb;
          # AUTHENTIK_POSTGRESQL__PASSWORD loaded from envFile
          AUTHENTIK_ERROR_REPORTING__ENABLED = "false";
        };
        volumes = [
          "${configPath}/authentik-media:/media:z"
          "${configPath}/authentik-templates:/templates:z"
          "${configPath}/authentik-certs:/certs:z"
          # Worker needs access to blueprints for discovery
          "${configPath}/authentik-blueprints:/blueprints/custom:z"
        ];
        network = "apps-net";
        dependsOn = [ "apps-network" "apps-postgres" "apps-redis" ];
        userns = "keep-id";
        # bloud-db-init creates the host-agent database (needed by prestart hook)
        # authentik-db-init creates the authentik database (needed by worker)
        extraAfter = [ "bloud-db-init.service" "authentik-db-init.service" ];
        extraRequires = [ "bloud-db-init.service" "authentik-db-init.service" ];
        waitFor = [
          { container = "apps-postgres"; command = "pg_isready -U ${postgresUser}"; }
          { container = "apps-redis"; command = "redis-cli ping"; }
        ];
      };

      # Authentik nginx proxy (adds X-Forwarded-Host header for correct OAuth URLs)
      podman-apps-authentik-proxy = mkPodmanService {
        name = "apps-authentik-proxy";
        image = "nginx:alpine";
        volumes = [
          "${configPath}/authentik-proxy.conf:/etc/nginx/conf.d/default.conf:ro"
        ];
        network = "apps-net";
        dependsOn = [ "apps-network" "apps-authentik-server" ];
      };
    } // lib.optionalAttrs appCfg.ldap.enable {
      # LDAP Outpost - provides LDAP protocol for apps like Jellyfin (TV/mobile clients)
      # Enabled by default (ldap.enable = true) as part of core Authentik infrastructure
      #
      # TIMING: The LDAP outpost is created by Authentik's PostStart (via API), but
      # systemd After= only waits for container start, not ExecStartPost completion.
      # So this prestart may run before the outpost exists. We handle this with retry logic.
      podman-apps-authentik-ldap = mkPodmanService {
        name = "apps-authentik-ldap";
        image = "ghcr.io/goauthentik/ldap:2025.10.3";
        ports = [
          "${toString appCfg.ldap.port}:3389"
          "${toString appCfg.ldap.securePort}:6636"
        ];
        # AUTHENTIK_HOST is static, AUTHENTIK_TOKEN comes from envFile
        environment = {
          # Connect to Authentik server via internal network
          AUTHENTIK_HOST = "http://apps-authentik-server:9000";
        };
        network = "apps-net";
        dependsOn = [ "apps-network" "apps-authentik-server" ];
        # Wait for Authentik to be ready before starting LDAP outpost
        extraAfter = [ "podman-apps-authentik-server.service" ];
        extraRequires = [ "podman-apps-authentik-server.service" ];
        waitFor = [
          { container = "apps-authentik-server"; command = "curl -sf http://localhost:9000/-/health/ready/ || exit 1"; }
        ];
        # Query Authentik for the auto-generated LDAP outpost token via Django shell
        # We use Django shell because the API doesn't expose token keys for security
        #
        # RACE CONDITION: Authentik's PostStart creates the LDAP outpost, but systemd
        # After= only waits for container start, not ExecStartPost. So we retry here.
        preStartScript = pkgs.writeShellScript "ldap-query-token" ''
          set -euo pipefail

          ENV_FILE="${configPath}/ldap-outpost.env"
          OUTPOST_NAME="Bloud LDAP Outpost"

          echo "Querying Authentik for LDAP outpost token via Django shell..."

          # Query the outpost token via Django shell (API doesn't expose token keys)
          # This gets the auto-generated token identifier and its key
          PYTHON_CODE='
from authentik.outposts.models import Outpost
from authentik.core.models import Token
try:
    outpost = Outpost.objects.get(name="'"$OUTPOST_NAME"'")
    token_id = f"ak-outpost-{outpost.pk}-api"
    token = Token.objects.get(identifier=token_id)
    print(f"TOKEN_KEY={token.key}")
except Outpost.DoesNotExist:
    print("ERROR: Outpost not found")
    exit(1)
except Token.DoesNotExist:
    print("ERROR: Token not found")
    exit(1)
'

          # Wait for the outpost to be created by Authentik PostStart (up to 90 seconds)
          # Authentik PostStart runs after container is healthy, creates token + LDAP infra via API
          for i in {1..30}; do
            RESULT=$(${pkgs.podman}/bin/podman exec apps-authentik-server ak shell -c "$PYTHON_CODE" 2>/dev/null | grep -E "^(TOKEN_KEY=|ERROR:)" || true)

            if echo "$RESULT" | grep -q "^TOKEN_KEY="; then
              TOKEN_KEY=$(echo "$RESULT" | sed 's/TOKEN_KEY=//')
              echo "Token retrieved successfully"
              echo "AUTHENTIK_TOKEN=$TOKEN_KEY" > "$ENV_FILE"
              chmod 600 "$ENV_FILE"
              echo "LDAP outpost token written to env file"
              exit 0
            fi

            if echo "$RESULT" | grep -q "ERROR:"; then
              echo "Waiting for LDAP outpost to be created by Authentik PostStart... ($i/30)"
              sleep 3
            else
              echo "Waiting for Authentik to respond... ($i/30)"
              sleep 3
            fi
          done

          echo "ERROR: Could not retrieve LDAP outpost token after 90 seconds"
          echo "This usually means Authentik's PostStart failed to create the LDAP infrastructure"
          exit 1
        '';
        # Pass the token via env file
        envFile = "${configPath}/ldap-outpost.env";
      };
    };

    # Create nginx proxy config for Authentik
    # NOTE: We intentionally do NOT set X-Forwarded-Host here.
    # This allows Authentik to return URLs with the actual Host header.
    # - When accessed via Traefik (browser): Traefik sets X-Forwarded-Host → localhost:8080 URLs
    # - When accessed via apps-authentik-proxy (container): Host is apps-authentik-proxy → internal URLs
    # This is critical for server-to-server OAuth token exchange from containers.
    # Atomic write to prevent nginx from seeing truncated file
    system.activationScripts.bloud-authentik-proxy-config = lib.stringAfter [ "bloud-authentik-dirs" ] ''
      cat > ${configPath}/authentik-proxy.conf.tmp <<'EOF'
server {
    listen 80;
    server_name _;

    location / {
        proxy_pass http://apps-authentik-server:9000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
EOF
      mv ${configPath}/authentik-proxy.conf.tmp ${configPath}/authentik-proxy.conf
      chown ${bloudCfg.user}:users ${configPath}/authentik-proxy.conf
    '';
  };
}
