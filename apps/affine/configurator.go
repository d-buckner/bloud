package affine

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"codeberg.org/d-buckner/bloud-v3/services/host-agent/pkg/configurator"
)

// Configurator handles AFFiNE configuration
type Configurator struct {
	port           int
	dataDir        string
	ssoBaseURL     string
	openidClientID string
	openidSecret   string
}

// NewConfigurator creates a new AFFiNE configurator
func NewConfigurator(port int, dataDir, ssoBaseURL, openidClientID, openidSecret string) *Configurator {
	return &Configurator{
		port:           port,
		dataDir:        dataDir,
		ssoBaseURL:     ssoBaseURL,
		openidClientID: openidClientID,
		openidSecret:   openidSecret,
	}
}

// Name returns the app name
func (c *Configurator) Name() string {
	return "affine"
}

// PreStart generates the affine.js config file for OIDC when SSO is enabled
func (c *Configurator) PreStart(ctx context.Context, state *configurator.AppState) error {
	configDir := filepath.Join(c.dataDir, "affine")
	configPath := filepath.Join(configDir, "affine.js")

	// Ensure config directory exists
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config dir: %w", err)
	}

	// Check if SSO integration is enabled
	if _, hasSSO := state.Integrations["sso"]; !hasSSO {
		// No SSO - create empty config file so volume mount doesn't fail
		if err := os.WriteFile(configPath, []byte("// No SSO configured\n"), 0644); err != nil {
			return fmt.Errorf("failed to write empty config: %w", err)
		}
		return nil
	}

	// Generate OIDC config
	issuer := fmt.Sprintf("%s/application/o/affine/", c.ssoBaseURL)

	config := fmt.Sprintf(`// Auto-generated by Bloud configurator
AFFiNE.use('oauth', {
  providers: {
    oidc: {
      issuer: '%s',
      clientId: '%s',
      clientSecret: '%s',
      args: {
        scope: 'openid email profile offline_access',
        claim_id: 'sub',
        claim_email: 'email',
        claim_name: 'name',
      },
    },
  },
});
`, issuer, c.openidClientID, c.openidSecret)

	if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("failed to write affine.js config: %w", err)
	}

	return nil
}

// HealthCheck waits for AFFiNE to be ready
func (c *Configurator) HealthCheck(ctx context.Context) error {
	url := fmt.Sprintf("http://localhost:%d/", c.port)
	return configurator.WaitForHTTP(ctx, url, configurator.DefaultHealthCheckTimeout)
}

// PostStart handles post-startup configuration
func (c *Configurator) PostStart(ctx context.Context, state *configurator.AppState) error {
	// No post-start configuration needed for AFFiNE
	return nil
}
