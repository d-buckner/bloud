package nixgen

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// AppConfig represents an app's configuration in Nix
type AppConfig struct {
	Name         string
	Integrations map[string]string
	Enabled      bool
}

// GlobalConfig represents global Nix configuration options
type GlobalConfig struct {
	// AuthentikLDAPEnable enables the LDAP outpost container for apps like Jellyfin
	AuthentikLDAPEnable bool
}

// Transaction represents a complete Nix configuration change
type Transaction struct {
	Apps   map[string]AppConfig
	Global GlobalConfig
}

// Generator generates Nix configuration files
type Generator struct {
	configPath string // Path to apps.nix
	statePath  string // Path to apps-state.json
	nixosPath  string // Path to nixos/ directory
}

// NewGenerator creates a Nix config generator
func NewGenerator(configPath, nixosPath string) *Generator {
	// State file is alongside the config file
	statePath := strings.TrimSuffix(configPath, ".nix") + "-state.json"
	return &Generator{
		configPath: configPath,
		statePath:  statePath,
		nixosPath:  nixosPath,
	}
}

// LoadCurrent loads the current app configuration from the state file
func (g *Generator) LoadCurrent() (*Transaction, error) {
	data, err := os.ReadFile(g.statePath)
	if os.IsNotExist(err) {
		// No state file yet - return empty transaction
		return &Transaction{Apps: make(map[string]AppConfig)}, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to read state file: %w", err)
	}

	var tx Transaction
	if err := json.Unmarshal(data, &tx); err != nil {
		return nil, fmt.Errorf("failed to parse state file: %w", err)
	}

	if tx.Apps == nil {
		tx.Apps = make(map[string]AppConfig)
	}

	return &tx, nil
}

// Apply applies a transaction by generating Nix config and saving state
func (g *Generator) Apply(tx *Transaction) error {
	// Generate the Nix config
	config := g.generateConfig(tx)

	// Ensure parent directory exists
	dir := filepath.Dir(g.configPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Write Nix config atomically (write temp file, then rename)
	tempPath := g.configPath + ".tmp"
	if err := os.WriteFile(tempPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	if err := os.Rename(tempPath, g.configPath); err != nil {
		os.Remove(tempPath)
		return fmt.Errorf("failed to update config: %w", err)
	}

	// Write state file for persistence
	stateData, err := json.MarshalIndent(tx, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal state: %w", err)
	}

	tempStatePath := g.statePath + ".tmp"
	if err := os.WriteFile(tempStatePath, stateData, 0644); err != nil {
		return fmt.Errorf("failed to write state file: %w", err)
	}

	if err := os.Rename(tempStatePath, g.statePath); err != nil {
		os.Remove(tempStatePath)
		return fmt.Errorf("failed to update state file: %w", err)
	}

	return nil
}

// generateConfig generates the complete Nix configuration
func (g *Generator) generateConfig(tx *Transaction) string {
	var b strings.Builder

	b.WriteString("# Generated by Bloud - DO NOT EDIT MANUALLY\n")
	b.WriteString("# This file is managed by the Bloud host agent\n")
	b.WriteString("{ config, lib, pkgs, ... }:\n\n")
	b.WriteString("{\n")

	// Note: App modules are imported by the main NixOS configuration (vm-dev.nix)
	// This file only enables/configures apps that are installed

	// Generate global configurations
	if tx.Global.AuthentikLDAPEnable {
		b.WriteString("  bloud.apps.authentik.ldap.enable = true;\n")
	}

	// Generate app configurations
	if len(tx.Apps) > 0 {
		// Sort apps for deterministic output
		var appNames []string
		for name := range tx.Apps {
			appNames = append(appNames, name)
		}
		sort.Strings(appNames)

		for _, name := range appNames {
			app := tx.Apps[name]
			if !app.Enabled {
				continue
			}

			// Always output enable = true for enabled apps
			// Note: Integration config is stored in state but not emitted to Nix
			// since the Nix modules handle their own integration (e.g., database URLs)
			b.WriteString(fmt.Sprintf("  bloud.apps.%s.enable = true;\n", name))
		}
	}

	b.WriteString("}\n")

	return b.String()
}

// getModulePath returns the Nix import path for an app module
func (g *Generator) getModulePath(appName string) string {
	// Relative path from config location to nixos/apps/
	return fmt.Sprintf("../../nixos/apps/%s.nix", appName)
}

// Preview generates a preview of what the config will look like
func (g *Generator) Preview(tx *Transaction) string {
	return g.generateConfig(tx)
}

// Diff shows the difference between current and proposed config
func (g *Generator) Diff(current, proposed *Transaction) string {
	// Simple text-based diff for now
	var changes []string

	// Find additions
	for name, app := range proposed.Apps {
		if app.Enabled {
			if currApp, exists := current.Apps[name]; !exists || !currApp.Enabled {
				changes = append(changes, fmt.Sprintf("+ Install %s", name))
			}
		}
	}

	// Find removals
	for name, app := range current.Apps {
		if app.Enabled {
			if propApp, exists := proposed.Apps[name]; !exists || !propApp.Enabled {
				changes = append(changes, fmt.Sprintf("- Remove %s", name))
			}
		}
	}

	// Find configuration changes
	for name, propApp := range proposed.Apps {
		if !propApp.Enabled {
			continue
		}
		if currApp, exists := current.Apps[name]; exists && currApp.Enabled {
			// Check for integration changes
			for intName, newSource := range propApp.Integrations {
				if oldSource, hasInt := currApp.Integrations[intName]; hasInt {
					if oldSource != newSource {
						changes = append(changes, fmt.Sprintf("~ Update %s.%s: %s â†’ %s", name, intName, oldSource, newSource))
					}
				} else {
					changes = append(changes, fmt.Sprintf("+ Configure %s.%s = %s", name, intName, newSource))
				}
			}
		}
	}

	if len(changes) == 0 {
		return "No changes"
	}

	return strings.Join(changes, "\n")
}
